   (1) % Define rigid frames, variables, points, and constants
   (2) RigidFrame N, B, Bbalance, CY, CX, CZ
   (3) Variable qBx'', qCx'', qCy'', qCz''
   (4) Point N0(N), Bcm(B), CXcm(CX), CYcm(CY), CZcm(CZ)
   (5) Constant L
   (6) Constant q1_balance = 45 degrees
   (7) % Define relations between reference frames
   (8) Bbalance.Rotate(N, nz>, q1_balance)
-> (9) Bbalance_N = [cos(q1_balance), sin(q1_balance), 0;  -sin(q1_balance), 
       cos(q1_balance), 0;  0, 0, 1]
-> (10) w_Bbalance_N> = 0>
-> (11) alf_Bbalance_N> = 0>

   (12) B.Rotate(Bbalance, nx>, qBx'')
-> (13) B_Bbalance[1,1] = cos(qBx'') + cos(q1_balance)^2*(1-cos(qBx''))
-> (14) B_Bbalance[1,2] = -sin(q1_balance)*cos(q1_balance)*(1-cos(qBx''))
-> (15) B_Bbalance[1,3] = sin(q1_balance)*sin(qBx'')
-> (16) B_Bbalance[2,1] = -sin(q1_balance)*cos(q1_balance)*(1-cos(qBx''))
-> (17) B_Bbalance[2,2] = cos(qBx'') + sin(q1_balance)^2*(1-cos(qBx''))
-> (18) B_Bbalance[2,3] = cos(q1_balance)*sin(qBx'')
-> (19) B_Bbalance[3,1] = -sin(q1_balance)*sin(qBx'')
-> (20) B_Bbalance[3,2] = -cos(q1_balance)*sin(qBx'')
-> (21) B_Bbalance[3,3] = cos(qBx'')

   (22) CX.Rotatex(B, qCx)
-> (23) CX_B = [1, 0, 0;  0, cos(qCx), sin(qCx);  0, -sin(qCx), cos(qCx)]
-> (24) w_CX_B> = qCx'*CXx>
-> (25) alf_CX_B> = qCx''*CXx>

   (26) CY.RotateY(B, qCy)
-> (27) CY_B = [cos(qCy), 0, -sin(qCy);  0, 1, 0;  sin(qCy), 0, cos(qCy)]
-> (28) w_CY_B> = qCy'*CYy>
-> (29) alf_CY_B> = qCy''*CYy>

   (30) CZ.RotateZ(B, qCz)
-> (31) CZ_B = [cos(qCz), sin(qCz), 0;  -sin(qCz), cos(qCz), 0;  0, 0, 1]
-> (32) w_CZ_B> = qCz'*CZz>
-> (33) alf_CZ_B> = qCz''*CZz>

   (34) % Display angular velocities and angular accelerations
   (35) w_B_N> = qBx'*nx>
-> (36) w_B_N> = qBx'*Nx>

   (37) alf_B_N> = qBx''*nx>
-> (38) alf_B_N> = qBx''*Nx>

   (39) % Define positions of points of interest
   (40) p_N0_Bcm> = L/3 * bx> + L/3 * by> + L/3 * bz>
-> (41) p_N0_Bcm> = 0.3333333*L*Bx> + 0.3333333*L*By> + 0.3333333*L*Bz>

   (42) p_N0_CXcm> = L/2 * by> + L/2 * Bz>
-> (43) p_N0_CXcm> = 0.5*L*By> + 0.5*L*Bz>

   (44) p_N0_CYcm> = L/2 * bx> + L/2 * Bz>
-> (45) p_N0_CYcm> = 0.5*L*Bx> + 0.5*L*Bz>

   (46) p_N0_CZcm> = L/2 * bx> + L/2 * by>
-> (47) p_N0_CZcm> = 0.5*L*Bx> + 0.5*L*By>

   (48) % Calculate velocities and accelerations of points of interest
   (49) v_N0_N> = 0>
-> (50) v_N0_N> = 0>

   (51) Bcm.SetVelocity(N, Dt(p_N0_Bcm>, N))
-> (52) v_Bcm_N> = -0.3333333*L*sin(q1_balance)*qBx'*Bx> - 0.3333333*L*cos(q1_
        balance)*qBx'*By> + 0.3333333*L*(sin(q1_balance)+cos(q1_balance))*qBx'*Bz>

   (53) Bcm.SetAcceleration(N, Dt(v_Bcm_N>, N))
-> (54) a_Bcm_N> = -0.3333333*L*sin(q1_balance)*((sin(q1_balance)+cos(q1_balan
        ce))*qBx'^2+qBx'')*Bx> - 0.3333333*L*cos(q1_balance)*((sin(q1_balance)+
        cos(q1_balance))*qBx'^2+qBx'')*By> - 0.3333333*L*(qBx'^2-(sin(q1_balan
        ce)+cos(q1_balance))*qBx'')*Bz>

   (55) % CZcm.SetVelocity(N, Dt(p_N0_CZcm>, N))
   (56) % CZcm.SetAcceleration(N, Dt(v_CZcm_N>, N))
   (57) % Compute angular momentum of the rotor and cube
   (58) help
